<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=393, height=852, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>둥둥그라운드 v1.8.5 - PNG & Space Retry</title>
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        @import url('https://fonts.googleapis.com/css2?family=Tomorrow:wght@500;600;700&display=swap');
        
        body { margin: 0; padding: 0; background-color: #333; font-family: 'Pretendard', sans-serif; overflow: hidden; touch-action: none; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-container { position: relative; width: 393px; height: 852px; overflow: hidden; background: #BBE5FF; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        #main-screen { position: absolute; inset: 0; background: url('bg_main.png') no-repeat center center / cover; z-index: 100; }
        #rive-canvas { position: absolute; top: 0; left: 0; width: 393px; height: 852px; pointer-events: none; z-index: 105; }
        canvas { display: block; width: 100%; height: 100%; outline: none; -webkit-tap-highlight-color: transparent; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; z-index: 50; display: none; pointer-events: none; }
        .nav-bar img { width: 100%; display: block; }
        .hud-info { width: 100%; padding: 9px 20px 0; box-sizing: border-box; display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-left { display: flex; align-items: center; gap: 1px; }
        .hud-left img { width: 28px; height: 28px; object-fit: contain; }
        .dist-val-wrap { font-family: "Tomorrow", sans-serif; font-size: 36px; font-weight: 600; color: #000; letter-spacing: -1px; line-height: 1; display: flex; align-items: baseline; }
        .dist-unit { font-family: 'Pretendard', sans-serif; font-size: 20px; font-weight: 700; margin-left: 1px; color: inherit; }
        #altitude-area.is-danger .dist-val-wrap, #altitude-area.is-danger #dist-val, #altitude-area.is-danger .dist-unit { color: #D4574B !important; }
        .danger-pulse { animation: extreme-pulse 0.135s infinite alternate ease-in-out; }
        @keyframes extreme-pulse { from { transform: scale(1.0); } to { transform: scale(1.1); } }
        .hud-right { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; }
        .ingame-score-bg { background: #fff; height: 38px; width: 86px; padding: 0 10px; border-radius: 30px; display: flex; align-items: center; justify-content: space-between; box-sizing: border-box; }
        .ingame-score-bg img { width: 28px; height: 28px; object-fit: contain; }
        .ingame-score-bg span { font-family: "Tomorrow", sans-serif; font-size: 18px; font-weight: 600; color: #000; }

        /* 라이프 UI: 간격 2px, 숫자 17px, 컬러 블랙 고정 */
        #life-container { display: flex; align-items: center; gap: 2px; padding-right: 4px; margin-top: -2px; }
        #life-icon { width: 40px; height: 40px; object-fit: contain; }
        #life-text { font-family: "Tomorrow", sans-serif; font-size: 17px; font-weight: 500; color: #000; letter-spacing: 0.5px; }

        #result-screen { position: absolute; inset: 0; background:rgba(0,0,0,0.8); z-index:200; display:none; flex-direction:column; justify-content:center; align-items:center; color:white; text-align:center; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="main-screen">
        <canvas id="rive-canvas"></canvas>
        <img src="btn_start.svg" id="start-btn" style="position:absolute; bottom:8%; left:50%; transform:translateX(-50%); width:85%; cursor:pointer; z-index: 110;" onclick="forceStart()">
    </div>

    <div id="hud">
        <div class="nav-bar"><img src="ingae_Navigation.png"></div>
        <div class="hud-info">
            <div id="altitude-area" class="hud-left">
                <img src="ico_meter.svg" id="dist-icon">
                <div class="dist-val-wrap"><span id="dist-val">1500</span><span class="dist-unit">m</span></div>
            </div>
            <div class="hud-right">
                <div class="ingame-score-bg">
                    <img src="create_s.svg">
                    <span id="score-val">0</span>
                </div>
                <div id="life-container">
                    <img id="life-icon" src="life.png">
                    <span id="life-text">x 3</span>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="result-screen">
        <h1 id="result-title" style="font-size: 48px; font-weight: 900;">작전 완료!</h1>
        <p style="font-size: 20px; margin: 10px 0;">획득한 보급: <span id="final-score" style="font-family:'Tomorrow'">0</span>개</p>
        <p style="font-size: 14px; opacity: 0.7; margin-bottom: 20px;">[Space]를 눌러 재도전</p>
        <img src="btn_start.svg" id="retry-btn" style="width: 70%; cursor:pointer;" onclick="location.reload()">
    </div>
</div>

<script>
    /* --- Rive 및 키보드 제어 --- */
    let riveInstance = null;
    function initRive() {
        riveInstance = new rive.Rive({
            src: 'dongdongground_0.1.riv', 
            canvas: document.getElementById('rive-canvas'),
            autoplay: true,
            stateMachines: 'State Machine 1', 
            layout: new rive.Layout({ fit: rive.Fit.Cover, alignment: rive.Alignment.Center }),
            onLoad: () => { riveInstance.resizeDrawingSurfaceToCanvas(); },
        });
    }
    window.addEventListener('load', initRive);

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            if (state === 'MAIN') forceStart();
            else if (state === 'PLAY') { pDir *= -1; windTimer = 0; windAlphaBase = 0; }
            else if (state === 'END') location.reload();
        }
    });

    function forceStart() {
        if (state !== 'MAIN') return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if(riveInstance) riveInstance.cleanup(); 
        document.getElementById('main-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        state = 'PLAY';
        for(let j=0; j<5; j++) spawnCloud(Math.random() * HEIGHT);
        loop(); 
    }

    /* --- 게임 물리 및 오디오 --- */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const now = audioCtx.currentTime;
        if (type === 'item') { 
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1600, now + 0.08);
            gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.1);
        } else if (type === 'hit') { 
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'triangle'; osc.frequency.setValueAtTime(250, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
            gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.15);
        } else if (type === 'gold') { 
            for(let i=0; i<3; i++) {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                const startTime = now + (i * 0.04);
                osc.type = 'sine'; osc.frequency.setValueAtTime(1000 + (i * 300), startTime);
                osc.frequency.exponentialRampToValueAtTime(2000 + (i * 300), startTime + 0.05);
                gain.gain.setValueAtTime(0.1, startTime); gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.05);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(startTime); osc.stop(startTime + 0.05);
            }
        }
    }

    const canvas = document.getElementById('gameCanvas');
    const WIDTH = 393 * 2, HEIGHT = 852 * 2; 
    canvas.width = WIDTH; canvas.height = HEIGHT;
    const ctx = canvas.getContext('2d');
    const imgs = {};
    const imgList = ['player', 'dong_chun.svg', 'face_happy', 'dong_chun_happy.svg', 'face_miss', 'dong_chun_miss.svg', 'crate', 'create_m.png', 'gold', 'gold.svg', 'heli', 'heli.png', 'cloud1', 'cloud_1.svg', 'cloud2', 'cloud_2.svg', 'cloud3', 'cloud_3.svg', 'land', '03_ingame_land.png', 'effect', 'effect_pickup.png', 'damage', 'damege.svg', 'mountain', 'surface_mountain.png', 'grass', 'surface_grass.png', 'target', 'surface_target.svg', 'windL', 'wind_L.svg', 'windR', 'wind_R.svg', 'windL_move', 'wind_L_move.svg', 'windR_move', 'wind_R_move.svg'];
    imgList.forEach((val, i) => { if(i % 2 === 0) { imgs[val] = new Image(); imgs[val].src = imgList[i+1]; } });

    let state = 'MAIN', frame = 0, dist = 1500, score = 0, lives = 3;
    let combo = 0, comboTimer = 0, popScale = 1.0, isGoldFever = false;
    let comboParticles = []; let windTimer = 0, windAlphaBase = 0;
    const pX = WIDTH / 2, pY = HEIGHT * 0.28;
    let pDir = 1, objects = [], clouds = [], fx = [];
    let stopSpawning = false, mountainX = 0, grassX = 0, hitShakeFrame = 0;
    let faceTimer = 0, currentFace = 'normal', currentRotation = 0, rotVel = 0;
    const springK = 0.18, friction = 0.75, GLOBAL_SPEED = 17.7; 
    let landY = HEIGHT + 1000, spawnDeck = [];

    function refillSpawnDeck() {
        let newItems = ['GOLD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD'];
        for(let i=0; i<90; i++) newItems.push('CRATE');
        for (let i = newItems.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newItems[i], newItems[j]] = [newItems[j], newItems[i]]; }
        spawnDeck = [...newItems];
    }
    function spawnCloud(y) {
        const depth = Math.floor(Math.random() * 2);
        const baseScale = depth === 0 ? 0.39 : 0.26;
        clouds.push({ x: Math.random() * WIDTH, y: y || HEIGHT + 150, img: imgs['cloud'+(Math.floor(Math.random()*3)+1)], scale: baseScale * 1.3, alpha: depth === 0 ? 0.8 : 0.5, speed: depth === 0 ? 4.0 : 2.0, depth });
    }
    function spawnObj() {
        if(stopSpawning) return;
        if(spawnDeck.length === 0) refillSpawnDeck();
        const type = spawnDeck.shift(); 
        let x = Math.random() * (WIDTH - 120) + 60; 
        const spawnY = HEIGHT + 200;
        if(type === 'BAD') objects.push({ x, y: spawnY, type: 'BAD', img: imgs.heli, flipped: Math.random() > 0.5 });
        else if(type === 'GOLD') objects.push({ x, y: spawnY, type: 'GOLD', img: imgs.gold });
        else objects.push({ x, y: spawnY, type: 'CRATE', img: imgs.crate });
    }

    function updateLifeUI() { 
        const lifeTextEl = document.getElementById('life-text');
        if(lifeTextEl) {
            lifeTextEl.innerText = 'x ' + lives;
        }
    }

    function addCombo() {
        combo++; comboTimer = 30; popScale = 1.4;
        for(let i=0; i<8; i++) { comboParticles.push({ x: 250 * 2 + 20, y: (150 * 2) + 60, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15, life: 30, size: Math.random() * 6 + 4 }); }
    }
    function triggerGoldFever() {
        playSound('gold'); currentFace = 'happy'; faceTimer = 78; isGoldFever = true; 
        objects.forEach(o => { if(o.type === 'CRATE') { score += (combo >= 20) ? 2 : 1; addCombo(); fx.push({ x: o.x, y: o.y, img: imgs.effect, life: 60, follow: false, vy: -5, isEffect: true }); } });
        objects = [];
    }
    function gameOver(title) {
        state = 'END'; document.getElementById('result-title').innerText = title;
        document.getElementById('final-score').innerText = score;
        document.getElementById('result-screen').style.display = 'flex';
    }

    canvas.addEventListener('mousedown', () => { if(state === 'PLAY') { pDir *= -1; windTimer = 0; windAlphaBase = 0; } });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if(state === 'PLAY') { pDir *= -1; windTimer = 0; windAlphaBase = 0; } }, {passive: false});

    function loop() {
        if(state === 'END') return;
        frame++; 
        if (isGoldFever) comboTimer = 30;
        else { if (comboTimer > 0) comboTimer--; else combo = 0; }

        if(popScale > 1.0) popScale -= 0.08; if(popScale < 1.0) popScale = 1.0;
        let targetRot = (pDir === 1) ? -27 * Math.PI / 180 : 0;
        rotVel = (rotVel + (targetRot - currentRotation) * springK) * friction;
        currentRotation += rotVel;
        if(state === 'PLAY') {
            dist -= 1.29; mountainX -= pDir * 2.07; grassX -= pDir * 11.5;
            if(frame % 7 === 0) spawnObj(); if(frame % 80 === 0) spawnCloud();
            windTimer++; if(windTimer > 18) { if(windAlphaBase < 1) windAlphaBase += 0.1; }
        }
        comboParticles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if(p.life <= 0) comboParticles.splice(i, 1); });
        const currentDist = Math.max(0, Math.floor(dist));
        document.getElementById('dist-val').innerText = currentDist;
        const altitudeArea = document.getElementById('altitude-area');
        if(currentDist <= 300) { altitudeArea.classList.add('is-danger'); if(currentDist > 0 && state === 'PLAY') altitudeArea.classList.add('danger-pulse'); else altitudeArea.classList.remove('danger-pulse');
        } else altitudeArea.classList.remove('is-danger', 'danger-pulse');
        document.getElementById('score-val').innerText = score;
        const targetArrivalY = pY + 140 - 248;
        if(dist < 150 && state === 'PLAY') { if(landY > targetArrivalY) landY -= GLOBAL_SPEED; else { landY = targetArrivalY; if(dist <= 5) { dist = 0; state = 'LANDED'; setTimeout(() => gameOver("작전 완료!"), 500); } } stopSpawning = true; }
        objects.forEach((o, i) => { o.y -= GLOBAL_SPEED; o.x -= pDir * 11.5; if(o.y < -200) { objects.splice(i, 1); return; } 
            if(state === 'PLAY' && Math.sqrt((pX - o.x)**2 + (pY - o.y)**2) < 115) {
                if(o.type === 'BAD') { playSound('hit'); lives--; score = Math.max(0, score - 10); combo = 0; comboTimer = 0; isGoldFever = false; updateLifeUI(); hitShakeFrame = 10; currentFace = 'miss'; faceTimer = 78; fx.push({ x: pX + 70, y: pY + 20, img: imgs.damage, life: 60, follow: true, vy: -4.2, isEffect: false }); if(lives <= 0) setTimeout(() => gameOver("작전 실패..."), 500);
                } else if(o.type === 'GOLD') triggerGoldFever();
                else { playSound('item'); score += (combo >= 20) ? 2 : 1; addCombo(); if(isGoldFever) isGoldFever = false; fx.push({ x: o.x, y: o.y, img: imgs.effect, life: 60, follow: false, vy: -5, isEffect: true }); }
                objects.splice(i, 1);
            }
        });
        clouds.forEach(c => { c.y -= c.speed; c.x -= pDir * c.speed * 0.3; });
        fx.forEach((f, i) => { f.life--; if(f.life <= 0) { fx.splice(i, 1); return; } if(!f.follow) { f.x -= pDir * 11.5; f.y -= GLOBAL_SPEED; } f.y += f.vy || 0; });
        if(hitShakeFrame > 0) hitShakeFrame--; draw(); requestAnimationFrame(loop);
    }

    function draw() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#BBE5FF'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
        
        clouds.forEach(c => { if(c.img.complete) { ctx.save(); ctx.globalAlpha = c.alpha; ctx.drawImage(c.img, c.x - (c.img.width*c.scale*2), c.y, c.img.width*c.scale*4, c.img.height*c.scale*4); ctx.restore(); } });
        ctx.save();
        if(dist < 150) {
            if(imgs.mountain.complete) { const mW = imgs.mountain.width * 0.82, mH = imgs.mountain.height * 0.82; for(let x = -3; x <= 3; x++) ctx.drawImage(imgs.mountain, ((mountainX * 1.0) % mW) + (x * mW), landY - mH, mW, mH); }
            if(imgs.grass.complete) { ctx.fillStyle = '#71C8AD'; ctx.fillRect(0, landY, WIDTH, HEIGHT); for(let x = -2; x <= 2; x++) ctx.drawImage(imgs.grass, ((grassX * 1.0) % WIDTH) + (x * WIDTH), landY, WIDTH, imgs.grass.height); }
            if(imgs.target.complete) { const tW = imgs.target.width || 240, tH = imgs.target.height || 96; ctx.drawImage(imgs.target, pX - tW, landY + 180, tW * 2, tH * 2); }
        }
        ctx.restore();

        if(state === 'PLAY' && windAlphaBase > 0) {
            let imgNormal, imgMove; if(pDir === 1) { imgNormal = imgs.windR; imgMove = imgs.windR_move; } else { imgNormal = imgs.windL; imgMove = imgs.windL_move; }
            if(imgNormal.complete && imgMove.complete) { ctx.save(); const s = 205; const baseX = WIDTH / 2 - s, baseY = 110 * 2; ctx.globalAlpha = windAlphaBase; ctx.drawImage(imgNormal, baseX, baseY, s * 2, s * 2); ctx.globalAlpha = windAlphaBase * (0.4 + Math.sin(frame * 0.25) * 0.4); ctx.drawImage(imgMove, baseX, baseY, s * 2, s * 2); ctx.restore(); }
        }
        
        objects.forEach(o => { 
            if(o.img.complete) { 
                ctx.save(); 
                if(o.type === 'CRATE') { 
                    ctx.translate(o.x, o.y - (o.img.height/2)); 
                    ctx.rotate(Math.sin(frame * 0.13 + o.y * 0.005) * 0.2); 
                    ctx.drawImage(o.img, -o.img.width/2, 0, o.img.width, o.img.height); 
                } else if(o.type === 'BAD') {
                    ctx.translate(o.x, o.y); 
                    if(o.flipped) ctx.scale(-1, 1); 
                    ctx.drawImage(o.img, -o.img.width/2, -o.img.height/2, o.img.width, o.img.height); 
                } else {
                    ctx.translate(o.x, o.y);
                    ctx.drawImage(o.img, -o.img.width, -o.img.height, o.img.width * 2, o.img.height * 2);
                }
                ctx.restore(); 
            } 
        });

        ctx.save(); let sX = (hitShakeFrame > 0) ? (Math.random() - 0.5) * 25 : 0; ctx.translate(pX + sX, pY + Math.sin(frame*0.08)*7.5); ctx.rotate(currentRotation); 
        let pImg = (faceTimer > 0) ? (currentFace === 'happy' ? imgs.face_happy : imgs.face_miss) : imgs.player;
        if(faceTimer > 0) faceTimer--; if(pImg.complete) ctx.drawImage(pImg, -pImg.width, -pImg.height, pImg.width * 2, pImg.height * 2); ctx.restore();
        fx.forEach(f => { if(f.img.complete) { ctx.save(); ctx.globalAlpha = Math.min(1, f.life / 20); if(f.isEffect) { ctx.drawImage(f.img, f.x - f.img.width / 2, f.y - f.img.height / 2, f.img.width, f.img.height); } else { ctx.drawImage(f.img, f.x - f.img.width, f.y - f.img.height, f.img.width * 2, f.img.height * 2); } ctx.restore(); } });
        comboParticles.forEach(p => { ctx.fillStyle = '#FFEF6B'; ctx.globalAlpha = p.life / 30; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
        ctx.restore(); 
        if(combo > 1 || isGoldFever) {
            ctx.save(); const comboX = 250 * 2, comboY = (150 * 2) + 32; ctx.translate(comboX, comboY); ctx.scale(popScale, popScale); ctx.translate(-comboX, -comboY); ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.lineJoin = 'round'; ctx.lineWidth = 10; ctx.filter = 'blur(0.5px)'; ctx.strokeStyle = '#FFFFFF'; ctx.fillStyle = (combo >= 20) ? '#A45AE4' : '#5094F9'; ctx.font = '700 80px "Tomorrow"'; ctx.strokeText(combo, comboX, comboY); ctx.fillText(combo, comboX, comboY); ctx.font = '700 32px "Pretendard"'; ctx.strokeText((combo >= 20) ? 'COMBO x2' : 'COMBO', comboX, comboY + 80); ctx.fillText((combo >= 20) ? 'COMBO x2' : 'COMBO', comboX, comboY + 80); ctx.filter = 'none'; ctx.restore();
        }
    }
    draw();
</script>
</body>
</html>
